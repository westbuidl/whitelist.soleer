"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionsClient = void 0;
const utils_1 = require("@trezor/utils");
const utils_2 = require("@trezor/utils");
class SessionsClient extends utils_2.TypedEmitter {
    constructor() {
        super(...arguments);
        this.request = () => {
            throw new Error('SessionsClient: request method not provided');
        };
        this.caller = (0, utils_1.getWeakRandomId)(3);
        this.id = 0;
    }
    init({ requestFn, registerBackgroundCallbacks, }) {
        this.id = 0;
        this.request = params => {
            if (!requestFn) {
                throw new Error('SessionsClient: requestFn not provided');
            }
            params.caller = this.caller;
            params.id = this.id;
            this.id++;
            return requestFn(params);
        };
        if (registerBackgroundCallbacks) {
            registerBackgroundCallbacks(descriptors => {
                this.emit('descriptors', descriptors);
            });
        }
    }
    handshake() {
        return this.request({ type: 'handshake' });
    }
    enumerateDone(payload) {
        return this.request({ type: 'enumerateDone', payload });
    }
    acquireIntent(payload) {
        return this.request({ type: 'acquireIntent', payload });
    }
    acquireDone(payload) {
        return this.request({ type: 'acquireDone', payload });
    }
    releaseIntent(payload) {
        return this.request({ type: 'releaseIntent', payload });
    }
    releaseDone(payload) {
        return this.request({ type: 'releaseDone', payload });
    }
    getSessions() {
        return this.request({ type: 'getSessions' });
    }
    getPathBySession(payload) {
        return this.request({ type: 'getPathBySession', payload });
    }
    dispose() {
        this.removeAllListeners('descriptors');
        return this.request({ type: 'dispose' });
    }
}
exports.SessionsClient = SessionsClient;
//# sourceMappingURL=client.js.map